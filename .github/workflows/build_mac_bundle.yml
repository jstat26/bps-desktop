name: Build Mac .app Bundle (portable R + r_lib + release)

on:
  workflow_dispatch:
    inputs:
      source_folder:
        description: "Top-level folder in repo root containing _BPS_Dashboard_App_Files (do not modify)"
        required: true
        default: "BPS Mac Desktop 2.0"
      app_name:
        description: "App name (produces <app_name>.app)"
        required: true
        default: "BPS Analytics Dashboard"
      r_version:
        description: "R version to install on runner (e.g., 4.4.2)"
        required: true
        default: "4.4.2"
      release_tag:
        description: "Release tag (optional). Leave blank to auto-generate."
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-mac-app:
    runs-on: macos-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ github.event.inputs.r_version }}

      - name: Verify R is available
        shell: bash
        run: |
          set -euo pipefail
          which R
          R --version
          which Rscript
          Rscript --version

      - name: Derive paths + output names
        shell: bash
        run: |
          set -euo pipefail

          SRC="${{ inputs.source_folder }}"
          APPDIR="$SRC/_BPS_Dashboard_App_Files (do not modify)"
          APP_NAME="${{ inputs.app_name }}"

          SAFE_SRC="$(echo "$SRC" | sed 's/[^A-Za-z0-9._-]/-/g')"
          SAFE_APP="$(echo "$APP_NAME" | sed 's/[^A-Za-z0-9._-]/-/g')"

          OUT_ZIP="Mac_${SAFE_APP}_${SAFE_SRC}_PortableR_with_r_lib.app.zip"

          echo "SRC=$SRC" >> "$GITHUB_ENV"
          echo "APPDIR=$APPDIR" >> "$GITHUB_ENV"
          echo "APP_NAME=$APP_NAME" >> "$GITHUB_ENV"
          echo "OUT_ZIP=$OUT_ZIP" >> "$GITHUB_ENV"

          echo "SRC     : $SRC"
          echo "APPDIR  : $APPDIR"
          echo "APP_NAME: $APP_NAME"
          echo "OUT_ZIP : $OUT_ZIP"

      - name: Verify source paths exist
        shell: bash
        run: |
          set -euo pipefail
          [[ -d "$SRC" ]] || { echo "Bundle folder not found: $SRC"; ls -la; exit 1; }
          [[ -d "$APPDIR" ]] || { echo "App folder not found: $APPDIR"; find "$SRC" -maxdepth 2 -type d -print; exit 1; }

          for f in app.R launch_app.R prep_r_lib.R; do
            [[ -f "$APPDIR/$f" ]] || { echo "Missing $APPDIR/$f"; ls -la "$APPDIR"; exit 1; }
          done

      - name: Clean macOS artifact files (if any)
        shell: bash
        run: |
          set -euo pipefail
          # remove common junk if it exists in repo files
          find "$SRC" -name ".DS_Store" -delete || true
          find "$SRC" -name "._*" -delete || true
          rm -rf "$SRC/__MACOSX" || true

      - name: Build r_lib inside the source app folder (forced lib path + diagnostics)
        shell: bash
        run: |
          set -euo pipefail
          cd "$APPDIR"

          # Create local shipped library
          mkdir -p r_lib

          # Absolute path to shipped lib
          RLIB="$(cd r_lib && pwd)"
          echo "Target shipped r_lib: $RLIB"

          # Force R to use this library FIRST (and often exclusively)
          export R_LIBS_USER="$RLIB"
          export R_LIBS="$RLIB"

          # Also set the env vars your prep script likely expects (based on your Windows workflow)
          export BPS_BUNDLE_DIR="$(cd "$SRC" && pwd)"
          export BPS_R_LIB="$RLIB"
          export BPS_DASH_LIB="$RLIB"

          echo "---- Pre-run diagnostics ----"
          Rscript --vanilla -e 'cat("R_LIBS_USER=", Sys.getenv("R_LIBS_USER"), "\n");
                                cat("R_LIBS=", Sys.getenv("R_LIBS"), "\n");
                                cat("BPS_R_LIB=", Sys.getenv("BPS_R_LIB"), "\n");
                                cat(".libPaths BEFORE:\n"); print(.libPaths())'

          # Run your prep script
          Rscript --vanilla prep_r_lib.R

          echo "---- Post-run diagnostics ----"
          Rscript --vanilla -e 'cat(".libPaths AFTER:\n"); print(.libPaths());
                                p <- Sys.getenv("R_LIBS_USER");
                                cat("Installed packages found in R_LIBS_USER:\n");
                                ip <- installed.packages(lib.loc=p);
                                cat(nrow(ip), "packages\n");
                                if (nrow(ip) > 0) print(head(ip[,c("Package","Version")], 30))'

          # Count package folders robustly (top-level dirs under r_lib)
          COUNT="$(find r_lib -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')"
          echo "r_lib package folders (top-level): $COUNT"

          # Fallback: if packages went into a nested structure, count deeper
          if [[ "$COUNT" -lt 10 ]]; then
            DEEP_COUNT="$(find r_lib -type d -maxdepth 2 -mindepth 2 | wc -l | tr -d ' ')"
            echo "r_lib package folders (deeper scan): $DEEP_COUNT"
          fi

          [[ "$COUNT" -ge 10 ]] || { 
            echo "r_lib looks too small; prep_r_lib.R likely installed to a different library on the runner."
            echo "Listing r_lib contents:"
            find r_lib -maxdepth 3 -type d -print
            exit 1
          }
          
      - name: Create .app bundle skeleton
        shell: bash
        run: |
          set -euo pipefail
          rm -rf dist artifacts
          mkdir -p "dist/$APP_NAME.app/Contents/MacOS" \
                   "dist/$APP_NAME.app/Contents/Resources" \
                   "dist/$APP_NAME.app/Contents/Frameworks"

          cat > "dist/$APP_NAME.app/Contents/Info.plist" <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleDevelopmentRegion</key><string>English</string>
            <key>CFBundleExecutable</key><string>launcher</string>
            <key>CFBundleIconFile</key><string>AppIcon</string>
            <key>CFBundleIdentifier</key><string>org.bps.analytics.dashboard</string>
            <key>CFBundleInfoDictionaryVersion</key><string>6.0</string>
            <key>CFBundleName</key><string>${APP_NAME}</string>
            <key>CFBundleDisplayName</key><string>${APP_NAME}</string>
            <key>CFBundlePackageType</key><string>APPL</string>
            <key>CFBundleShortVersionString</key><string>2.0</string>
            <key>CFBundleVersion</key><string>2.0</string>
            <key>LSMinimumSystemVersion</key><string>11.0</string>
            <key>NSHighResolutionCapable</key><true/>
          </dict>
          </plist>
          PLIST

      - name: Build and install macOS app icon (AppIcon.icns)
        shell: bash
        run: |
          set -euo pipefail

          # Source PNG already in your repo folder structure
          ICON_PNG="$APPDIR/www/BPS-District-Logo.png"

          APP_RES="dist/$APP_NAME.app/Contents/Resources"
          [[ -f "$ICON_PNG" ]] || { echo "Icon PNG not found: $ICON_PNG"; ls -la "$APPDIR/www" || true; exit 1; }

          # Make sure the source is square (icons must be NxN)
          W="$(sips -g pixelWidth  "$ICON_PNG" | tail -n1 | awk '{print $2}')"
          H="$(sips -g pixelHeight "$ICON_PNG" | tail -n1 | awk '{print $2}')"
          echo "Icon source dimensions: ${W}x${H}"
          if [[ "$W" != "$H" ]]; then
            echo "ERROR: icon PNG must be square. Got ${W}x${H} at $ICON_PNG"
            exit 1
          fi

          rm -rf AppIcon.iconset AppIcon.icns
          mkdir -p AppIcon.iconset

          # Generate the standard icon sizes
          sips -z 16 16     "$ICON_PNG" --out AppIcon.iconset/icon_16x16.png
          sips -z 32 32     "$ICON_PNG" --out AppIcon.iconset/icon_16x16@2x.png
          sips -z 32 32     "$ICON_PNG" --out AppIcon.iconset/icon_32x32.png
          sips -z 64 64     "$ICON_PNG" --out AppIcon.iconset/icon_32x32@2x.png
          sips -z 128 128   "$ICON_PNG" --out AppIcon.iconset/icon_128x128.png
          sips -z 256 256   "$ICON_PNG" --out AppIcon.iconset/icon_128x128@2x.png
          sips -z 256 256   "$ICON_PNG" --out AppIcon.iconset/icon_256x256.png
          sips -z 512 512   "$ICON_PNG" --out AppIcon.iconset/icon_256x256@2x.png
          sips -z 512 512   "$ICON_PNG" --out AppIcon.iconset/icon_512x512.png
          sips -z 1024 1024 "$ICON_PNG" --out AppIcon.iconset/icon_512x512@2x.png

          iconutil -c icns AppIcon.iconset

          mkdir -p "$APP_RES"
          mv -f AppIcon.icns "$APP_RES/AppIcon.icns"

          echo "Installed icon at: $APP_RES/AppIcon.icns"
          ls -lh "$APP_RES/AppIcon.icns"

      - name: Copy dashboard files into .app (match launch_app.R expected layout)
        shell: bash
        run: |
          set -euo pipefail

          RES="dist/$APP_NAME.app/Contents/Resources"
          mkdir -p "$RES/_BPS_Dashboard_App_Files (do not modify)"
          mkdir -p "$RES/r_lib"

          # Copy app code, but EXCLUDE r_lib (we'll place it at Resources/r_lib)
          rsync -a --delete --exclude "r_lib/" \
            "$APPDIR/" \
            "$RES/_BPS_Dashboard_App_Files (do not modify)/"

          # Copy shipped r_lib to Resources/r_lib
          rsync -a --delete \
            "$APPDIR/r_lib/" \
            "$RES/r_lib/"

      - name: Bundle R.framework into the .app (robust path)
        shell: bash
        run: |
          set -euo pipefail
          RHOME="$(R RHOME)"
          echo "R RHOME: $RHOME"

          FRAMEWORK="$(cd "$RHOME/.." && pwd)"
          echo "R.framework: $FRAMEWORK"

          [[ -d "$FRAMEWORK" ]] || { echo "Derived R.framework not found: $FRAMEWORK"; exit 1; }

          rsync -a "$FRAMEWORK" "dist/$APP_NAME.app/Contents/Frameworks/"

          [[ -x "dist/$APP_NAME.app/Contents/Frameworks/R.framework/Resources/bin/Rscript" ]] || {
            echo "Bundled Rscript missing inside .app"
            find "dist/$APP_NAME.app/Contents/Frameworks/R.framework" -maxdepth 4 -name "Rscript" -print
            exit 1
          }

      - name: Create launcher executable
        shell: bash
        run: |
          set -euo pipefail
          LAUNCHER="dist/$APP_NAME.app/Contents/MacOS/launcher"

          cat > "$LAUNCHER" <<'SH'
          #!/bin/bash
          set -euo pipefail

          APP_DIR="$(cd "$(dirname "$0")/.." && pwd)"
          RES_DIR="$APP_DIR/Resources"

          R_FRAMEWORK="$APP_DIR/Frameworks/R.framework"
          export R_HOME="$R_FRAMEWORK/Resources"
          export PATH="$R_HOME/bin:$PATH"

          # Tell the shared launch_app.R what "bundle root" is on mac
          export BPS_APP_DIR="$RES_DIR"
          export BPS_DASH_LIB="$RES_DIR/r_lib"
          export R_LIBS_USER="$RES_DIR/r_lib"

          LOG_DIR="$HOME/Library/Logs/BPS_Analytics_Dashboard"
          mkdir -p "$LOG_DIR"
          TS="$(date +%Y%m%d_%H%M%S)"
          LOG_FILE="$LOG_DIR/launch_${TS}.log"

          {
            echo "APP_DIR=$APP_DIR"
            echo "RES_DIR=$RES_DIR"
            echo "R_HOME=$R_HOME"
            echo "BPS_APP_DIR=$BPS_APP_DIR"
            echo "BPS_DASH_LIB=$BPS_DASH_LIB"
            echo "R_LIBS_USER=$R_LIBS_USER"
            echo "R version:"
            R --version || true
            echo "----- launching app -----"
          } >> "$LOG_FILE" 2>&1

          "$R_HOME/bin/Rscript" --vanilla \
            "$RES_DIR/_BPS_Dashboard_App_Files (do not modify)/launch_app.R" \
            >> "$LOG_FILE" 2>&1
          SH

          chmod +x "$LAUNCHER"

      - name: Ad-hoc codesign (helps some systems)
        shell: bash
        run: |
          set -euo pipefail
          codesign --force --deep --sign - "dist/$APP_NAME.app" || true

      - name: Zip the .app for distribution
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts
          ditto -c -k --sequesterRsrc --keepParent "dist/$APP_NAME.app" "artifacts/$OUT_ZIP"
          ls -lh artifacts

      - name: Upload artifact (zip)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mac-app-bundle
          path: artifacts/*.zip
          if-no-files-found: error

      - name: Compute release tag/name
        if: success()
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ github.event.inputs.release_tag }}"
          if [[ -z "${TAG// }" ]]; then
            SAFE_SRC="$(echo "$SRC" | sed 's/[^A-Za-z0-9._-]/-/g')"
            TAG="mac-${SAFE_SRC}-${{ github.run_number }}"
          fi
          echo "RELEASE_TAG=$TAG" >> "$GITHUB_ENV"
          echo "RELEASE_NAME=Mac App Bundle - $SRC (run ${{ github.run_number }})" >> "$GITHUB_ENV"
          echo "Release tag: $TAG"

      - name: Create GitHub Release (attach zip)
        if: success()
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          generate_release_notes: true
          files: artifacts/${{ env.OUT_ZIP }}

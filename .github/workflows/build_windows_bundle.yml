name: Build Windows Bundle (dynamic folder + portable R + r_lib + healthcheck + release)

on:
  workflow_dispatch:
    inputs:
      bundle_dir:
        description: "Top-level bundle folder in repo root (e.g., BPS Windows Desktop 1-3.1)"
        required: true
        default: "BPS Windows Desktop 1-2.1"
      r_version:
        description: "R version to use (e.g., 4.4.2)."
        required: true
        default: "4.4.2"
      release_tag:
        description: "Release tag (optional). Leave blank to auto-generate."
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-windows-bundle:
    runs-on: windows-latest

    env:
      # Provided at dispatch time
      BUNDLE_DIR: ${{ github.event.inputs.bundle_dir }}

      # Relative paths INSIDE the bundle folder
      PREP_REL_PATH: "_BPS_Dashboard_App_Files (do not modify)/prep_r_lib.R"
      APP_REL_PATH: "_BPS_Dashboard_App_Files (do not modify)/app.R"

      # Reliable repo for CI
      R_REPO: "https://packagemanager.posit.co/cran/latest"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ github.event.inputs.r_version }}

      - name: Print runner R version
        shell: pwsh
        run: |
          Rscript -e "cat('Runner R version: ', R.version.string, '\n')"

      - name: Derive script paths + versioned zip name
        shell: pwsh
        run: |
          $bundle = "$env:BUNDLE_DIR"
          $prep   = Join-Path $bundle "$env:PREP_REL_PATH"
          $app    = Join-Path $bundle "$env:APP_REL_PATH"
          $appDir = Split-Path -Parent $app

          $safe = $bundle -replace '[^A-Za-z0-9._-]','-'
          $zip  = "BPS_Windows_${safe}_PortableR_with_r_lib.zip"

          "PREP_SCRIPT=$prep" | Out-File -FilePath $env:GITHUB_ENV -Append
          "APP_SCRIPT=$app"   | Out-File -FilePath $env:GITHUB_ENV -Append
          "APP_DIR=$appDir"   | Out-File -FilePath $env:GITHUB_ENV -Append
          "OUT_ZIP=$zip"      | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "BUNDLE_DIR : $bundle"
          Write-Host "PREP_SCRIPT: $prep"
          Write-Host "APP_SCRIPT : $app"
          Write-Host "APP_DIR    : $appDir"
          Write-Host "OUT_ZIP    : $zip"

      - name: Verify bundle paths exist
        shell: pwsh
        run: |
          if (!(Test-Path "$env:BUNDLE_DIR"))  { throw "Bundle directory not found: $env:BUNDLE_DIR" }
          if (!(Test-Path "$env:PREP_SCRIPT")) { throw "prep_r_lib.R not found at: $env:PREP_SCRIPT" }
          if (!(Test-Path "$env:APP_SCRIPT"))  { throw "app.R not found at: $env:APP_SCRIPT" }

      - name: Clean macOS artifact files from bundle (if any)
        shell: pwsh
        run: |
          $bundle = (Resolve-Path "$env:BUNDLE_DIR").Path
          $macosx = Join-Path $bundle "__MACOSX"
          if (Test-Path $macosx) { Remove-Item -Recurse -Force $macosx }

          Get-ChildItem -Path $bundle -Recurse -Force -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -eq ".DS_Store" -or $_.Name -like "._*" } |
            ForEach-Object { Remove-Item -Force $_.FullName -ErrorAction SilentlyContinue }

          Write-Host "Cleanup complete."

      - name: Bundle portable R runtime into the app folder
        shell: pwsh
        run: |
          $rhome = Rscript -e "cat(R.home())"
          if (!(Test-Path $rhome)) { throw "R.home() not found: $rhome" }

          $bundle = (Resolve-Path "$env:BUNDLE_DIR").Path
          $dest   = Join-Path $bundle "R"

          if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          Copy-Item -Recurse -Force -Path "$rhome\*" -Destination $dest

          $rscript = Join-Path $dest "bin\Rscript.exe"
          $rexe    = Join-Path $dest "bin\R.exe"
          if (!(Test-Path $rscript)) { throw "Bundled Rscript not found at: $rscript" }
          if (!(Test-Path $rexe))    { throw "Bundled R.exe not found at: $rexe" }

          Write-Host "Bundled R runtime into: $dest"
          & $rscript -e "cat('Bundled R version: ', R.version.string, '\n')"
          & $rscript -e "cat('Bundled R.home(): ', R.home(), '\n'); cat('Bundled Rscript: ', Sys.which('Rscript'), '\n')"

      - name: Build shipped r_lib using bundled R
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          if (!(Test-Path $bundleR)) { throw "Bundled Rscript missing: $bundleR" }

          $rlib = Join-Path $bundle "r_lib"
          if (Test-Path $rlib) { Remove-Item -Recurse -Force $rlib }
          New-Item -ItemType Directory -Force -Path $rlib | Out-Null

          $env:BPS_BUNDLE_DIR = $bundle
          $env:BPS_R_LIB      = $rlib
          $env:BPS_DASH_LIB   = $rlib
          $env:R_REPO         = "$env:R_REPO"

          & $bundleR --vanilla "$env:PREP_SCRIPT"

          $count = (Get-ChildItem $rlib -Directory | Measure-Object).Count
          if ($count -lt 10) { throw "r_lib looks too small ($count package folders). prep_r_lib.R may be writing to the wrong location." }

          Write-Host "r_lib built at: $rlib"
          Get-ChildItem $rlib -Directory | Select-Object -First 25 | ForEach-Object { $_.Name }

      - name: Ensure app-required packages exist (e.g., tidyverse)
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib    = Join-Path $bundle "r_lib"
          $rlib_fs = ($rlib -replace '\\','/')

          $expr = @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))
          needed <- c('tidyverse')
          missing <- needed[!sapply(needed, requireNamespace, quietly=TRUE)]
          if (length(missing)) {
            cat('Installing missing:', paste(missing, collapse=', '), '\n')
            install.packages(missing, dependencies=TRUE)
          }
          cat('Required package check complete.\n')
          "@

          & $bundleR --vanilla -e $expr

      - name: Smoke test (load key packages from shipped r_lib using bundled R)
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib    = Join-Path $bundle "r_lib"

          $pkgs = @(
            "shiny","bs4Dash","DT",
            "tidyverse",
            "dplyr","tidyr","ggplot2","plotly","readr","readxl","lubridate","qs2"
          )

          $pkgs_r   = ($pkgs | ForEach-Object { "'$_'" }) -join ","
          $rlib_fs  = ($rlib -replace '\\','/')

          $expr = @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))
          cat('LibPaths:\n'); print(.libPaths())
          pkgs <- c($pkgs_r)
          ok <- sapply(pkgs, function(p) suppressWarnings(require(p, character.only=TRUE)))
          cat('\nLoad results:\n'); print(ok)
          if (any(!ok)) quit(status=2)
          "@

          & $bundleR --vanilla -e $expr

      - name: Launch Shiny app (background) using bundled R + shipped r_lib (READY handshake)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $bundle   = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR  = Join-Path $bundle "R\bin\Rscript.exe"
          if (!(Test-Path $bundleR)) { throw "Bundled Rscript missing: $bundleR" }

          $rlib     = Join-Path $bundle "r_lib"
          $appDir   = (Resolve-Path "$env:APP_DIR").Path

          $rlib_fs  = ($rlib -replace '\\','/')
          $appDirFs = ($appDir -replace '\\','/')

          $port = Get-Random -Minimum 10000 -Maximum 20000
          $bindHost = "127.0.0.1"
          $url = "http://$bindHost`:$port"

          $runFile   = Join-Path $env:RUNNER_TEMP "run_shiny_ready.R"
          $outLog    = Join-Path $env:RUNNER_TEMP "shiny_out.log"
          $errLog    = Join-Path $env:RUNNER_TEMP "shiny_err.log"
          $readyFile = Join-Path $env:RUNNER_TEMP "shiny_READY.txt"

          if (Test-Path $outLog) { Remove-Item -Force $outLog }
          if (Test-Path $errLog) { Remove-Item -Force $errLog }
          if (Test-Path $readyFile) { Remove-Item -Force $readyFile }

          @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))

          cat('--- SHINY LAUNCH BEGIN ---\n')
          cat('R.version: ', R.version.string, '\n')
          cat('LibPaths:\n'); print(.libPaths())
          cat('App dir: $appDirFs\n')

          setwd('$appDirFs')
          cat('Working dir: ', getwd(), '\n')

          # Ensure cache.qs exists if your app expects it
          cache_path <- file.path(getwd(), 'cache.qs')
          if (!file.exists(cache_path)) {
            cat('cache.qs missing; creating minimal cache.qs at: ', cache_path, '\n')
            if (requireNamespace('qs2', quietly=TRUE)) qs2::qsave(list(), cache_path) else file.create(cache_path)
          } else {
            cat('cache.qs exists at: ', cache_path, '\n')
          }

          port <- as.integer($port)
          host <- '$bindHost'
          options(shiny.port = port, shiny.host = host)

          ready_file <- '$($readyFile -replace '\\','/')'
          ready_url  <- '$url'

          cat('Attempting to start Shiny on ', host, ':', port, '\n', sep='')
          cat('READY_FILE: ', ready_file, '\n')
          cat('READY_URL : ', ready_url, '\n')
          cat('--- SHINY LAUNCHING ---\n')

          # When Shiny prints "Listening on http://...", write READY file once.
          withCallingHandlers(
            shiny::runApp(appDir = getwd(), host = host, port = port, launch.browser = FALSE),
            message = function(m) {
              msg <- conditionMessage(m)
              cat(msg, '\n')
              if (!file.exists(ready_file) && grepl('Listening on http', msg, fixed=TRUE)) {
                writeLines(paste0('READY ', ready_url), ready_file)
                cat('WROTE READY FILE\n')
              }
              invokeRestart('muffleMessage')
            }
          )
          "@ | Set-Content -Encoding UTF8 $runFile

          Write-Host "Starting Shiny app on $url ..."
          $p = Start-Process -FilePath $bundleR `
                -WorkingDirectory $appDir `
                -ArgumentList @("--vanilla", $runFile) `
                -PassThru -WindowStyle Hidden `
                -RedirectStandardOutput $outLog `
                -RedirectStandardError  $errLog

          "SHINY_PID=$($p.Id)"         | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_URL=$url"             | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_OUT_LOG=$outLog"      | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_ERR_LOG=$errLog"      | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_PORT=$port"           | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_READY_FILE=$readyFile" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Shiny PID=$($p.Id)"
          Write-Host "READY file: $readyFile"
          Write-Host "stdout log: $outLog"
          Write-Host "stderr log: $errLog"

          # Quick sanity: if it dies instantly, dump logs right now
          Start-Sleep -Seconds 2
          try { Get-Process -Id $p.Id | Out-Null }
          catch {
            Write-Host "ERROR: Shiny process exited immediately."
            if (Test-Path $outLog) { Write-Host "----- shiny_out.log (tail 200) -----"; Get-Content $outLog -Tail 200 | ForEach-Object { Write-Host $_ } }
            if (Test-Path $errLog) { Write-Host "----- shiny_err.log (tail 200) -----"; Get-Content $errLog -Tail 200 | ForEach-Object { Write-Host $_ } }
            throw "Shiny process exited immediately."
          }
      - name: App startup assertion (log-based)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # wait up to 60s for "Listening on" to appear in logs
          $ok = $false
          for ($i=0; $i -lt 60; $i++) {
            # if process died, fail and print logs
            try { Get-Process -Id ([int]$env:SHINY_PID) | Out-Null }
            catch {
              Write-Host "Shiny PID exited early."
              if (Test-Path $env:SHINY_OUT_LOG) { Write-Host "----- shiny_out.log (tail 200) -----"; Get-Content $env:SHINY_OUT_LOG -Tail 200 }
              if (Test-Path $env:SHINY_ERR_LOG) { Write-Host "----- shiny_err.log (tail 200) -----"; Get-Content $env:SHINY_ERR_LOG -Tail 200 }
              throw "App failed to stay running during startup window."
            }

            # check logs for Listening
            if (Test-Path $env:SHINY_ERR_LOG) {
              $tail = Get-Content $env:SHINY_ERR_LOG -Tail 400 -ErrorAction SilentlyContinue | Out-String
              if ($tail -match "Listening on http") { $ok = $true; break }
            }

            Start-Sleep -Seconds 1
          }

          if (-not $ok) {
            Write-Host "Did not see 'Listening on http' in logs."
            if (Test-Path $env:SHINY_OUT_LOG) { Write-Host "----- shiny_out.log (tail 200) -----"; Get-Content $env:SHINY_OUT_LOG -Tail 200 }
            if (Test-Path $env:SHINY_ERR_LOG) { Write-Host "----- shiny_err.log (tail 200) -----"; Get-Content $env:SHINY_ERR_LOG -Tail 200 }
            throw "Startup assertion failed: Shiny never reported Listening state."
          }

          Write-Host "Startup assertion passed: Shiny reported Listening."

      - name: Upload app health artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: app-health
          path: |
            ${{ runner.temp }}\app_health
            ${{ env.SHINY_READY_FILE }}
            ${{ env.SHINY_OUT_LOG }}
            ${{ env.SHINY_ERR_LOG }}
          if-no-files-found: warn

      - name: Stop Shiny app
        if: always()
        shell: pwsh
        run: |
          if ($env:SHINY_PID) {
            Write-Host "Stopping Shiny PID=$env:SHINY_PID"
            Stop-Process -Id $env:SHINY_PID -Force -ErrorAction SilentlyContinue
          }

      - name: Create zip (includes the top-level bundle folder)
        if: always()
        shell: pwsh
        run: |
          if (Test-Path "$env:OUT_ZIP") { Remove-Item -Force "$env:OUT_ZIP" }
          Compress-Archive -Path "$env:BUNDLE_DIR" -DestinationPath "$env:OUT_ZIP"
          Write-Host "Created zip: $env:OUT_ZIP"
          Get-Item "$env:OUT_ZIP" | Format-List

      - name: Upload artifact (zip)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-bundle-portableR-with_r_lib
          path: ${{ env.OUT_ZIP }}
          if-no-files-found: error

      - name: Compute release tag/name
        if: success()
        shell: pwsh
        run: |
          $tag = "${{ github.event.inputs.release_tag }}"
          if ([string]::IsNullOrWhiteSpace($tag)) {
            $safe = "$env:BUNDLE_DIR" -replace '[^A-Za-z0-9._-]','-'
            $tag = "windows-$safe-${{ github.run_number }}"
          }
          "RELEASE_TAG=$tag" | Out-File -FilePath $env:GITHUB_ENV -Append
          "RELEASE_NAME=Windows Bundle - $env:BUNDLE_DIR (run ${{ github.run_number }})" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Release tag: $tag"

      - name: Create GitHub Release (attach zip)
        if: success()
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          generate_release_notes: true
          files: ${{ env.OUT_ZIP }}

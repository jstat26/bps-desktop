name: Build Windows Bundle (dynamic folder + portable R + r_lib + healthcheck + release)

on:
  workflow_dispatch:
    inputs:
      bundle_dir:
        description: "Top-level bundle folder in repo root (e.g., BPS Windows Desktop 1-3.1)"
        required: true
        default: "BPS Windows Desktop 1-2.1"
      r_version:
        description: "R version to use (e.g., 4.4.2)."
        required: true
        default: "4.4.2"
      release_tag:
        description: "Release tag (optional). Leave blank to auto-generate."
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-windows-bundle:
    runs-on: windows-latest

    env:
      # Provided at dispatch time
      BUNDLE_DIR: ${{ github.event.inputs.bundle_dir }}

      # Relative paths INSIDE the bundle folder
      PREP_REL_PATH: "_BPS_Dashboard_App_Files (do not modify)/prep_r_lib.R"
      APP_REL_PATH: "_BPS_Dashboard_App_Files (do not modify)/app.R"

      # Reliable repo for CI
      R_REPO: "https://packagemanager.posit.co/cran/latest"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ github.event.inputs.r_version }}

      - name: Print runner R version
        shell: pwsh
        run: |
          Rscript -e "cat('Runner R version: ', R.version.string, '\n')"

      - name: Derive script paths + versioned zip name
        shell: pwsh
        run: |
          $bundle = "$env:BUNDLE_DIR"
          $prep   = Join-Path $bundle "$env:PREP_REL_PATH"
          $app    = Join-Path $bundle "$env:APP_REL_PATH"

          $safe = $bundle -replace '[^A-Za-z0-9._-]','-'
          $zip  = "BPS_Windows_${safe}_PortableR_with_r_lib.zip"

          "PREP_SCRIPT=$prep" | Out-File -FilePath $env:GITHUB_ENV -Append
          "APP_SCRIPT=$app"   | Out-File -FilePath $env:GITHUB_ENV -Append
          "OUT_ZIP=$zip"      | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "BUNDLE_DIR : $bundle"
          Write-Host "PREP_SCRIPT: $prep"
          Write-Host "APP_SCRIPT : $app"
          Write-Host "OUT_ZIP    : $zip"

      - name: Verify bundle paths exist
        shell: pwsh
        run: |
          if (!(Test-Path "$env:BUNDLE_DIR"))  { throw "Bundle directory not found: $env:BUNDLE_DIR" }
          if (!(Test-Path "$env:PREP_SCRIPT")) { throw "prep_r_lib.R not found at: $env:PREP_SCRIPT" }
          if (!(Test-Path "$env:APP_SCRIPT"))  { throw "app.R not found at: $env:APP_SCRIPT" }

      - name: Clean macOS artifact files from bundle (if any)
        shell: pwsh
        run: |
          $bundle = (Resolve-Path "$env:BUNDLE_DIR").Path
          $macosx = Join-Path $bundle "__MACOSX"
          if (Test-Path $macosx) { Remove-Item -Recurse -Force $macosx }

          Get-ChildItem -Path $bundle -Recurse -Force -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -eq ".DS_Store" -or $_.Name -like "._*" } |
            ForEach-Object { Remove-Item -Force $_.FullName -ErrorAction SilentlyContinue }

          Write-Host "Cleanup complete."

      - name: Bundle portable R runtime into the app folder
        shell: pwsh
        run: |
          $rhome = Rscript -e "cat(R.home())"
          if (!(Test-Path $rhome)) { throw "R.home() not found: $rhome" }

          $bundle = (Resolve-Path "$env:BUNDLE_DIR").Path
          $dest   = Join-Path $bundle "R"

          if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          Copy-Item -Recurse -Force -Path "$rhome\*" -Destination $dest

          $rscript = Join-Path $dest "bin\Rscript.exe"
          $rexe    = Join-Path $dest "bin\R.exe"
          if (!(Test-Path $rscript)) { throw "Bundled Rscript not found at: $rscript" }
          if (!(Test-Path $rexe))    { throw "Bundled R.exe not found at: $rexe" }

          Write-Host "Bundled R runtime into: $dest"
          & $rscript -e "cat('Bundled R version: ', R.version.string, '\n')"
          & $rscript -e "cat('Bundled R.home(): ', R.home(), '\n'); cat('Bundled Rscript: ', Sys.which('Rscript'), '\n')"

      - name: Build shipped r_lib using bundled R
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          if (!(Test-Path $bundleR)) { throw "Bundled Rscript missing: $bundleR" }

          $rlib = Join-Path $bundle "r_lib"
          if (Test-Path $rlib) { Remove-Item -Recurse -Force $rlib }
          New-Item -ItemType Directory -Force -Path $rlib | Out-Null

          $env:BPS_BUNDLE_DIR = $bundle
          $env:BPS_R_LIB      = $rlib
          $env:BPS_DASH_LIB   = $rlib
          $env:R_REPO         = "$env:R_REPO"

          & $bundleR --vanilla "$env:PREP_SCRIPT"

          $count = (Get-ChildItem $rlib -Directory | Measure-Object).Count
          if ($count -lt 10) { throw "r_lib looks too small ($count package folders). prep_r_lib.R may be writing to the wrong location." }

          Write-Host "r_lib built at: $rlib"
          Get-ChildItem $rlib -Directory | Select-Object -First 25 | ForEach-Object { $_.Name }

      - name: Ensure app-required packages exist (e.g., tidyverse)
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib    = Join-Path $bundle "r_lib"
          $rlib_fs = ($rlib -replace '\\','/')

          $expr = @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))
          needed <- c('tidyverse')
          missing <- needed[!sapply(needed, requireNamespace, quietly=TRUE)]
          if (length(missing)) {
            cat('Installing missing:', paste(missing, collapse=', '), '\n')
            install.packages(missing, dependencies=TRUE)
          }
          cat('Required package check complete.\n')
          "@

          & $bundleR --vanilla -e $expr

      - name: Smoke test (load key packages from shipped r_lib using bundled R)
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib    = Join-Path $bundle "r_lib"

          $pkgs = @(
            "shiny","bs4Dash","DT",
            "tidyverse",
            "dplyr","tidyr","ggplot2","plotly","readr","readxl","lubridate","qs2"
          )

          $pkgs_r   = ($pkgs | ForEach-Object { "'$_'" }) -join ","
          $rlib_fs  = ($rlib -replace '\\','/')

          $expr = @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))
          cat('LibPaths:\n'); print(.libPaths())
          pkgs <- c($pkgs_r)
          ok <- sapply(pkgs, function(p) suppressWarnings(require(p, character.only=TRUE)))
          cat('\nLoad results:\n'); print(ok)
          if (any(!ok)) quit(status=2)
          "@

          & $bundleR --vanilla -e $expr

      - name: Launch Shiny app (background) using bundled R + shipped r_lib
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $bundle   = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR  = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib     = Join-Path $bundle "r_lib"
          $appPath  = (Resolve-Path "$env:APP_SCRIPT").Path

          $rlib_fs = ($rlib -replace '\\','/')
          $app_fs  = ($appPath -replace '\\','/')

          $port = Get-Random -Minimum 10000 -Maximum 20000
          $bindHost = "127.0.0.1"
          $url = "http://$bindHost`:$port"

          $runFile = Join-Path $env:RUNNER_TEMP "run_shiny.R"
          $outLog  = Join-Path $env:RUNNER_TEMP "shiny_out.log"
          $errLog  = Join-Path $env:RUNNER_TEMP "shiny_err.log"

          @(
            "options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))",
            ".libPaths(c('$rlib_fs', .libPaths()))",
            "cat('LibPaths:\n'); print(.libPaths())",
            "cat('Working dir: ', getwd(), '\n')",
            "cat('App path: $app_fs\n')",
            "port <- as.integer($port)",
            "host <- '$bindHost'",
            "options(shiny.port = port, shiny.host = host)",
            "shiny::runApp('$app_fs', host=host, port=port, launch.browser=FALSE)"
          ) | Set-Content -Encoding UTF8 $runFile

          if (Test-Path $outLog) { Remove-Item -Force $outLog }
          if (Test-Path $errLog) { Remove-Item -Force $errLog }

          Write-Host "Starting Shiny app on $url ..."
          $p = Start-Process -FilePath $bundleR `
                -ArgumentList @("--vanilla", $runFile) `
                -PassThru -WindowStyle Hidden `
                -RedirectStandardOutput $outLog `
                -RedirectStandardError  $errLog

          "SHINY_PID=$($p.Id)"         | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_URL=$url"             | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_OUT_LOG=$outLog"      | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_ERR_LOG=$errLog"      | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_PORT=$port"           | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Shiny PID=$($p.Id)"
          Write-Host "stdout log: $outLog"
          Write-Host "stderr log: $errLog"

      - name: App health check (HTTP probe + save HTML)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $outDir = Join-Path $env:RUNNER_TEMP "app_health"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $readme = Join-Path $outDir "README.txt"
          "Health check started: $(Get-Date -Format o)" | Set-Content -Encoding UTF8 $readme
          Add-Content $readme "SHINY_URL=$env:SHINY_URL"
          Add-Content $readme "SHINY_PID=$env:SHINY_PID"
          Add-Content $readme "SHINY_OUT_LOG=$env:SHINY_OUT_LOG"
          Add-Content $readme "SHINY_ERR_LOG=$env:SHINY_ERR_LOG"

          function Try-Get($u) {
            try {
              return Invoke-WebRequest -Uri $u -UseBasicParsing -TimeoutSec 5
            } catch {
              return $null
            }
          }

          $resp = $null
          for ($i=0; $i -lt 90; $i++) {
            $resp = Try-Get $env:SHINY_URL
            if ($resp -and $resp.StatusCode -ge 200 -and $resp.StatusCode -lt 500) {
              Add-Content $readme "Probe OK: HTTP $($resp.StatusCode)"
              break
            }

            # fail fast if process died
            if ($env:SHINY_PID) {
              try { Get-Process -Id ([int]$env:SHINY_PID) | Out-Null }
              catch { Add-Content $readme "ERROR: Shiny PID exited early."; break }
            }

            Start-Sleep -Seconds 2
          }

          # Always capture log tails for debugging
          try {
            if ($env:SHINY_OUT_LOG -and (Test-Path $env:SHINY_OUT_LOG)) {
              Get-Content $env:SHINY_OUT_LOG -Tail 400 | Set-Content -Encoding UTF8 (Join-Path $outDir "shiny_out_tail.txt")
            }
            if ($env:SHINY_ERR_LOG -and (Test-Path $env:SHINY_ERR_LOG)) {
              Get-Content $env:SHINY_ERR_LOG -Tail 400 | Set-Content -Encoding UTF8 (Join-Path $outDir "shiny_err_tail.txt")
            }
          } catch {}

          if (-not $resp) {
            Add-Content $readme "ERROR: Shiny not reachable."
            throw "Health check failed: Shiny not reachable at $env:SHINY_URL"
          }

          # Save HTML for sanity inspection
          $htmlPath = Join-Path $outDir "home.html"
          $resp.Content | Set-Content -Encoding UTF8 $htmlPath
          Add-Content $readme "Saved HTML -> home.html"

          # Very light HTML sanity (do NOT overfit strings)
          if ($resp.Content -notmatch "<html" -and $resp.Content -notmatch "<!DOCTYPE") {
            Add-Content $readme "WARNING: HTML did not look like HTML (no <html/doctype found)."
          }

          Add-Content $readme "Health check complete."

      - name: Upload app health artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: app-health
          path: ${{ runner.temp }}\app_health
          if-no-files-found: warn

      - name: Stop Shiny app
        if: always()
        shell: pwsh
        run: |
          if ($env:SHINY_PID) {
            Write-Host "Stopping Shiny PID=$env:SHINY_PID"
            Stop-Process -Id $env:SHINY_PID -Force -ErrorAction SilentlyContinue
          }

      - name: Create zip (includes the top-level bundle folder)
        if: always()
        shell: pwsh
        run: |
          if (Test-Path "$env:OUT_ZIP") { Remove-Item -Force "$env:OUT_ZIP" }
          Compress-Archive -Path "$env:BUNDLE_DIR" -DestinationPath "$env:OUT_ZIP"
          Write-Host "Created zip: $env:OUT_ZIP"
          Get-Item "$env:OUT_ZIP" | Format-List

      - name: Upload artifact (zip)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-bundle-portableR-with_r_lib
          path: ${{ env.OUT_ZIP }}
          if-no-files-found: error

      - name: Compute release tag/name
        if: success()
        shell: pwsh
        run: |
          $tag = "${{ github.event.inputs.release_tag }}"
          if ([string]::IsNullOrWhiteSpace($tag)) {
            $safe = "$env:BUNDLE_DIR" -replace '[^A-Za-z0-9._-]','-'
            $tag = "windows-$safe-${{ github.run_number }}"
          }
          "RELEASE_TAG=$tag" | Out-File -FilePath $env:GITHUB_ENV -Append
          "RELEASE_NAME=Windows Bundle - $env:BUNDLE_DIR (run ${{ github.run_number }})" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Release tag: $tag"

      - name: Create GitHub Release (attach zip)
        if: success()
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          generate_release_notes: true
          files: ${{ env.OUT_ZIP }}

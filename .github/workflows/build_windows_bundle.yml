name: Build Windows Bundle (dynamic folder + portable R + r_lib + healthcheck + release)

on:
  workflow_dispatch:
    inputs:
      bundle_dir:
        description: "Top-level bundle folder in repo root (e.g., BPS Windows Desktop 1-3.1)"
        required: true
        default: "BPS Windows Desktop 1-2.1"
      r_version:
        description: "R version to use (e.g., 4.4.2)."
        required: true
        default: "4.4.2"
      release_tag:
        description: "Release tag (optional). Leave blank to auto-generate."
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-windows-bundle:
    runs-on: windows-latest

    env:
      # Provided at dispatch time
      BUNDLE_DIR: ${{ github.event.inputs.bundle_dir }}

      # Relative paths INSIDE the bundle folder
      PREP_REL_PATH: "_BPS_Dashboard_App_Files (do not modify)/prep_r_lib.R"
      APP_REL_PATH: "_BPS_Dashboard_App_Files (do not modify)/app.R"

      # Reliable repo for CI
      R_REPO: "https://packagemanager.posit.co/cran/latest"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ github.event.inputs.r_version }}

      - name: Print runner R version
        shell: pwsh
        run: |
          Rscript -e "cat('Runner R version: ', R.version.string, '\n')"

      - name: Derive script paths + versioned zip name
        shell: pwsh
        run: |
          $bundle = "$env:BUNDLE_DIR"
          $prep   = Join-Path $bundle "$env:PREP_REL_PATH"
          $app    = Join-Path $bundle "$env:APP_REL_PATH"
          $appDir = Split-Path -Parent $app

          $safe = $bundle -replace '[^A-Za-z0-9._-]','-'
          $zip  = "BPS_Windows_${safe}_PortableR_with_r_lib.zip"

          "PREP_SCRIPT=$prep" | Out-File -FilePath $env:GITHUB_ENV -Append
          "APP_SCRIPT=$app"   | Out-File -FilePath $env:GITHUB_ENV -Append
          "APP_DIR=$appDir"   | Out-File -FilePath $env:GITHUB_ENV -Append
          "OUT_ZIP=$zip"      | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "BUNDLE_DIR : $bundle"
          Write-Host "PREP_SCRIPT: $prep"
          Write-Host "APP_SCRIPT : $app"
          Write-Host "APP_DIR    : $appDir"
          Write-Host "OUT_ZIP    : $zip"

      - name: Verify bundle paths exist
        shell: pwsh
        run: |
          if (!(Test-Path "$env:BUNDLE_DIR"))  { throw "Bundle directory not found: $env:BUNDLE_DIR" }
          if (!(Test-Path "$env:PREP_SCRIPT")) { throw "prep_r_lib.R not found at: $env:PREP_SCRIPT" }
          if (!(Test-Path "$env:APP_SCRIPT"))  { throw "app.R not found at: $env:APP_SCRIPT" }

      - name: Clean macOS artifact files from bundle (if any)
        shell: pwsh
        run: |
          $bundle = (Resolve-Path "$env:BUNDLE_DIR").Path
          $macosx = Join-Path $bundle "__MACOSX"
          if (Test-Path $macosx) { Remove-Item -Recurse -Force $macosx }

          Get-ChildItem -Path $bundle -Recurse -Force -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -eq ".DS_Store" -or $_.Name -like "._*" } |
            ForEach-Object { Remove-Item -Force $_.FullName -ErrorAction SilentlyContinue }

          Write-Host "Cleanup complete."

      - name: Bundle portable R runtime into the app folder
        shell: pwsh
        run: |
          $rhome = Rscript -e "cat(R.home())"
          if (!(Test-Path $rhome)) { throw "R.home() not found: $rhome" }

          $bundle = (Resolve-Path "$env:BUNDLE_DIR").Path
          $dest   = Join-Path $bundle "R"

          if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          Copy-Item -Recurse -Force -Path "$rhome\*" -Destination $dest

          $rscript = Join-Path $dest "bin\Rscript.exe"
          $rexe    = Join-Path $dest "bin\R.exe"
          if (!(Test-Path $rscript)) { throw "Bundled Rscript not found at: $rscript" }
          if (!(Test-Path $rexe))    { throw "Bundled R.exe not found at: $rexe" }

          Write-Host "Bundled R runtime into: $dest"
          & $rscript -e "cat('Bundled R version: ', R.version.string, '\n')"
          & $rscript -e "cat('Bundled R.home(): ', R.home(), '\n'); cat('Bundled Rscript: ', Sys.which('Rscript'), '\n')"

      - name: Build shipped r_lib using bundled R
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          if (!(Test-Path $bundleR)) { throw "Bundled Rscript missing: $bundleR" }

          $rlib = Join-Path $bundle "r_lib"
          if (Test-Path $rlib) { Remove-Item -Recurse -Force $rlib }
          New-Item -ItemType Directory -Force -Path $rlib | Out-Null

          $env:BPS_BUNDLE_DIR = $bundle
          $env:BPS_R_LIB      = $rlib
          $env:BPS_DASH_LIB   = $rlib
          $env:R_REPO         = "$env:R_REPO"

          & $bundleR --vanilla "$env:PREP_SCRIPT"

          $count = (Get-ChildItem $rlib -Directory | Measure-Object).Count
          if ($count -lt 10) { throw "r_lib looks too small ($count package folders). prep_r_lib.R may be writing to the wrong location." }

          Write-Host "r_lib built at: $rlib"
          Get-ChildItem $rlib -Directory | Select-Object -First 25 | ForEach-Object { $_.Name }

      - name: Ensure app-required packages exist (e.g., tidyverse)
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib    = Join-Path $bundle "r_lib"
          $rlib_fs = ($rlib -replace '\\','/')

          $expr = @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))
          needed <- c('tidyverse')
          missing <- needed[!sapply(needed, requireNamespace, quietly=TRUE)]
          if (length(missing)) {
            cat('Installing missing:', paste(missing, collapse=', '), '\n')
            install.packages(missing, dependencies=TRUE)
          }
          cat('Required package check complete.\n')
          "@

          & $bundleR --vanilla -e $expr

      - name: Smoke test (load key packages from shipped r_lib using bundled R)
        shell: pwsh
        run: |
          $bundle  = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR = Join-Path $bundle "R\bin\Rscript.exe"
          $rlib    = Join-Path $bundle "r_lib"

          $pkgs = @(
            "shiny","bs4Dash","DT",
            "tidyverse",
            "dplyr","tidyr","ggplot2","plotly","readr","readxl","lubridate","qs2"
          )

          $pkgs_r   = ($pkgs | ForEach-Object { "'$_'" }) -join ","
          $rlib_fs  = ($rlib -replace '\\','/')

          $expr = @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))
          cat('LibPaths:\n'); print(.libPaths())
          pkgs <- c($pkgs_r)
          ok <- sapply(pkgs, function(p) suppressWarnings(require(p, character.only=TRUE)))
          cat('\nLoad results:\n'); print(ok)
          if (any(!ok)) quit(status=2)
          "@

          & $bundleR --vanilla -e $expr

      - name: Launch Shiny app (background) using bundled R + shipped r_lib (HARDENED)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $bundle   = (Resolve-Path "$env:BUNDLE_DIR").Path
          $bundleR  = Join-Path $bundle "R\bin\Rscript.exe"
          if (!(Test-Path $bundleR)) { throw "Bundled Rscript missing: $bundleR" }

          $rlib     = Join-Path $bundle "r_lib"
          $appDir   = (Resolve-Path "$env:APP_DIR").Path

          $rlib_fs  = ($rlib -replace '\\','/')
          $appDirFs = ($appDir -replace '\\','/')

          $port = Get-Random -Minimum 10000 -Maximum 20000
          $bindHost = "127.0.0.1"
          $url = "http://$bindHost`:$port"

          $runFile = Join-Path $env:RUNNER_TEMP "run_shiny.R"
          $outLog  = Join-Path $env:RUNNER_TEMP "shiny_out.log"
          $errLog  = Join-Path $env:RUNNER_TEMP "shiny_err.log"

          @"
          options(repos = c(CRAN = Sys.getenv('R_REPO', unset='https://cloud.r-project.org')))
          .libPaths(c('$rlib_fs', .libPaths()))

          cat('--- SHINY LAUNCH BEGIN ---\n')
          cat('R.version: ', R.version.string, '\n')
          cat('LibPaths:\n'); print(.libPaths())
          cat('App dir: $appDirFs\n')

          # Ensure working directory is app folder (relative paths!)
          setwd('$appDirFs')
          cat('Working dir: ', getwd(), '\n')

          # Ensure cache.qs exists if app expects it
          cache_path <- file.path(getwd(), 'cache.qs')
          if (!file.exists(cache_path)) {
            cat('cache.qs missing; creating minimal cache.qs at: ', cache_path, '\n')
            # if qs2 is available, write a tiny cache object; otherwise write an empty file
            if (requireNamespace('qs2', quietly=TRUE)) {
              qs2::qsave(list(), cache_path)
            } else {
              file.create(cache_path)
            }
          } else {
            cat('cache.qs exists at: ', cache_path, '\n')
          }

          port <- as.integer($port)
          host <- '$bindHost'
          options(shiny.port = port, shiny.host = host)

          cat('Attempting to start Shiny on ', host, ':', port, '\n', sep='')
          cat('--- SHINY LAUNCHING ---\n')

          tryCatch({
            shiny::runApp(appDir = getwd(), host = host, port = port, launch.browser = FALSE)
          }, error = function(e) {
            message('FATAL: Shiny failed to start: ', conditionMessage(e))
            message('TRACEBACK:')
            traceback(20)
            quit(status = 1)
          })
          "@ | Set-Content -Encoding UTF8 $runFile

          if (Test-Path $outLog) { Remove-Item -Force $outLog }
          if (Test-Path $errLog) { Remove-Item -Force $errLog }

          Write-Host "Starting Shiny app on $url ..."
          $p = Start-Process -FilePath $bundleR `
                -WorkingDirectory $appDir `
                -ArgumentList @("--vanilla", $runFile) `
                -PassThru -WindowStyle Hidden `
                -RedirectStandardOutput $outLog `
                -RedirectStandardError  $errLog

          # export env vars
          "SHINY_PID=$($p.Id)"         | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_URL=$url"             | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_OUT_LOG=$outLog"      | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_ERR_LOG=$errLog"      | Out-File -FilePath $env:GITHUB_ENV -Append
          "SHINY_PORT=$port"           | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Shiny PID=$($p.Id)"
          Write-Host "stdout log: $outLog"
          Write-Host "stderr log: $errLog"

          # FAIL FAST if process dies immediately; dump logs to console
          Start-Sleep -Seconds 2
          try {
            Get-Process -Id $p.Id | Out-Null
          } catch {
            Write-Host "ERROR: Shiny process exited immediately."
            if (Test-Path $outLog) {
              Write-Host "----- shiny_out.log (tail 200) -----"
              Get-Content $outLog -Tail 200 | ForEach-Object { Write-Host $_ }
            }
            if (Test-Path $errLog) {
              Write-Host "----- shiny_err.log (tail 200) -----"
              Get-Content $errLog -Tail 200 | ForEach-Object { Write-Host $_ }
            }
            throw "Shiny process exited immediately (before health check). See logs above."
          }

      - name: App health check (robust HTTP probe) + diagnostics
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $outDir = Join-Path $env:RUNNER_TEMP "app_health"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $readme = Join-Path $outDir "README.txt"
          "Health check started: $(Get-Date -Format o)" | Set-Content -Encoding UTF8 $readme
          Add-Content $readme "SHINY_URL=$env:SHINY_URL"
          Add-Content $readme "SHINY_PID=$env:SHINY_PID"
          Add-Content $readme "SHINY_PORT=$env:SHINY_PORT"
          Add-Content $readme "SHINY_OUT_LOG=$env:SHINY_OUT_LOG"
          Add-Content $readme "SHINY_ERR_LOG=$env:SHINY_ERR_LOG"

          function Dump-Logs {
            try {
              if ($env:SHINY_OUT_LOG -and (Test-Path $env:SHINY_OUT_LOG)) {
                Get-Content $env:SHINY_OUT_LOG -Tail 800 | Set-Content -Encoding UTF8 (Join-Path $outDir "shiny_out_tail.txt")
                Write-Host "----- shiny_out.log (tail 300) -----"
                Get-Content $env:SHINY_OUT_LOG -Tail 300 | ForEach-Object { Write-Host $_ }
              }
              if ($env:SHINY_ERR_LOG -and (Test-Path $env:SHINY_ERR_LOG)) {
                Get-Content $env:SHINY_ERR_LOG -Tail 800 | Set-Content -Encoding UTF8 (Join-Path $outDir "shiny_err_tail.txt")
                Write-Host "----- shiny_err.log (tail 300) -----"
                Get-Content $env:SHINY_ERR_LOG -Tail 300 | ForEach-Object { Write-Host $_ }
              }
            } catch {}
          }

          function Dump-NetworkDiagnostics {
            try {
              $port = [int]$env:SHINY_PORT
              Add-Content $readme "Net diagnostics for port $port:"
              Write-Host "----- netstat for port $port -----"
              cmd /c "netstat -ano | findstr :$port" | Tee-Object -FilePath (Join-Path $outDir "netstat_port.txt")
              Write-Host "----- tasklist for SHINY_PID $env:SHINY_PID -----"
              cmd /c "tasklist /FI ""PID eq $env:SHINY_PID""" | Tee-Object -FilePath (Join-Path $outDir "tasklist_pid.txt")
            } catch {}
          }

          # Fail fast if process already died
          try { Get-Process -Id ([int]$env:SHINY_PID) | Out-Null }
          catch {
            Add-Content $readme "ERROR: Shiny PID is not running at start of healthcheck."
            Dump-Logs
            throw "Health check failed: Shiny process not running."
          }

          $resp = $null
          $lastErr = $null

          # Robust probe loop (up to ~2 minutes)
          for ($i=0; $i -lt 120; $i++) {
            # if process died, stop immediately
            try { Get-Process -Id ([int]$env:SHINY_PID) | Out-Null }
            catch {
              Add-Content $readme "ERROR: Shiny PID exited during probe loop."
              Dump-Logs
              Dump-NetworkDiagnostics
              throw "Health check failed: Shiny process exited during probe loop."
            }

            # Prefer curl.exe (very reliable on Windows runners)
            $tmpHeaders = Join-Path $env:RUNNER_TEMP "curl_headers.txt"
            $tmpBody    = Join-Path $env:RUNNER_TEMP "curl_body.html"
            if (Test-Path $tmpHeaders) { Remove-Item -Force $tmpHeaders }
            if (Test-Path $tmpBody)    { Remove-Item -Force $tmpBody }

            $code = ""
            try {
              # -s silent, -S show errors, -L follow redirects, -m timeout seconds
              cmd /c "curl.exe -sS -L -m 5 -D ""$tmpHeaders"" -o ""$tmpBody"" ""$env:SHINY_URL"" & echo CURL_EXITCODE:%ERRORLEVEL%" | Out-Null
              $hdr = if (Test-Path $tmpHeaders) { Get-Content $tmpHeaders -Raw } else { "" }
              if ($hdr -match "HTTP/\d\.\d\s+(\d{3})") { $code = $Matches[1] }
            } catch {
              $lastErr = $_.Exception.Message
            }

            if ($code) {
              Add-Content $readme "Probe OK via curl: HTTP $code"
              Write-Host "Probe OK: HTTP $code"
              # Save body
              if (Test-Path $tmpBody) {
                Copy-Item -Force $tmpBody (Join-Path $outDir "home.html")
                Add-Content $readme "Saved HTML -> home.html"
              }
              break
            }

            Start-Sleep -Seconds 1
          }

          # If no success, dump everything and fail
          if (-not $code) {
            Add-Content $readme "ERROR: Could not fetch $env:SHINY_URL within timeout."
            if ($lastErr) { Add-Content $readme "Last error: $lastErr" }
            Dump-Logs
            Dump-NetworkDiagnostics
            throw "Health check failed: could not fetch $env:SHINY_URL"
          }

          Add-Content $readme "Health check complete."

      - name: Upload app health artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: app-health
          path: ${{ runner.temp }}\app_health
          if-no-files-found: warn

      - name: Stop Shiny app
        if: always()
        shell: pwsh
        run: |
          if ($env:SHINY_PID) {
            Write-Host "Stopping Shiny PID=$env:SHINY_PID"
            Stop-Process -Id $env:SHINY_PID -Force -ErrorAction SilentlyContinue
          }

      - name: Create zip (includes the top-level bundle folder)
        if: always()
        shell: pwsh
        run: |
          if (Test-Path "$env:OUT_ZIP") { Remove-Item -Force "$env:OUT_ZIP" }
          Compress-Archive -Path "$env:BUNDLE_DIR" -DestinationPath "$env:OUT_ZIP"
          Write-Host "Created zip: $env:OUT_ZIP"
          Get-Item "$env:OUT_ZIP" | Format-List

      - name: Upload artifact (zip)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-bundle-portableR-with_r_lib
          path: ${{ env.OUT_ZIP }}
          if-no-files-found: error

      - name: Compute release tag/name
        if: success()
        shell: pwsh
        run: |
          $tag = "${{ github.event.inputs.release_tag }}"
          if ([string]::IsNullOrWhiteSpace($tag)) {
            $safe = "$env:BUNDLE_DIR" -replace '[^A-Za-z0-9._-]','-'
            $tag = "windows-$safe-${{ github.run_number }}"
          }
          "RELEASE_TAG=$tag" | Out-File -FilePath $env:GITHUB_ENV -Append
          "RELEASE_NAME=Windows Bundle - $env:BUNDLE_DIR (run ${{ github.run_number }})" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Release tag: $tag"

      - name: Create GitHub Release (attach zip)
        if: success()
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          generate_release_notes: true
          files: ${{ env.OUT_ZIP }}
